# Workflow for the Engineer LLM: Single-main push, tests-before-commit

Principles
- Single branch policy: **only** push to `main`. No feature branches. Every task must be self-contained and independently testable locally before pushing.
- Atomic, well-tested commits: each push to `main` must implement exactly one task (as defined in tasks.mdc), include tests and a short commit message describing the task and its acceptance criteria.
- No CI/CD: the engineer LLM is responsible for running all tests and manual cross-OS builds before any push.
- Use LLVM as the backend for code generation. The compiler will emit LLVM IR and use the LLVM toolchain (`llc`/`clang`/`llvm-link`/`llvm-as`/`clang` as appropriate) to create native executables on target OSes.
- No pointers: the language subset intentionally omits pointers and pointer arithmetic. Memory safety is simpler; the runtime will provide heap-allocated boxed values where needed.

Daily loop for an atomic task
1. Claim the next **open** task from tasks.mdc.
2. Implement the minimal code that completes the task locally.
3. Add unit tests and end-to-end tests (compile-run-verify) that exercise the implemented behavior.
4. Run the entire local test suite (see `test/README.md` conventions in tasks.mdc). Fix failures until all tests pass locally.
5. Run cross-OS builds as required by the task (Linux x86_64, macOS x86_64/arm64, Windows x86_64). Use local VMs/containers or remote runners under your control — but **do not** push until builds succeed locally or in your controlled environment.
6. Commit with a concise message: `task-<id>: <short description> — <acceptance short>` and push to `main`.
7. Tag the commit with `task-<id>`.

Testing responsibilities
- Unit tests: cover lexer, parser, semantic analyzer, codegen pieces in isolation.
- Integration tests: input C-like source -> executable -> run tests and compare stdout/exit code/side-effects.
- Cross-platform smoke tests: build and run a small integration test on target OS (use static linking where feasible for reproducibility).
- Regression tests: whenever a bug is fixed, add a regression test that would have failed previously.

Release and backward compatibility
- No releases or branches. `main` is the single source-of-truth.
- Keep the language stable; any non-backward-compatible change must be accompanied by a migration task in tasks.mdc and conversion tooling if necessary.

Toolchain and environment
- Primary implementation language: C++. Use Makefile for build system.
- Required local tools: LLVM (12+ recommended), `clang` for linking on some platforms, `llc`, `llvm-as`, `llvm-link`, `opt` (optional), C++ toolchain for compiler implementation.
- Build scripts: Provide `Makefile` to bootstrap and produce artifacts using system LLVM.

Conventions
- Code style: project uses consistent C++ style with clang-format where applicable.
- Tests placed under `tests/` for integration tests and `src/*_test.cpp` for unit tests.
- Each task must update `tasks.mdc` to mark status `done` when committed.

Failure handling
- If a push breaks the test suite in `main`, immediately revert with `git revert` and open a follow-up task assigned to the same engineer to diagnose and fix.